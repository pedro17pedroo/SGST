import {
  users, categories, suppliers, warehouses, products, inventory, stockMovements, orders, orderItems, shipments,
  productLocations, inventoryCounts, inventoryCountItems, barcodeScans,
  pickingLists, pickingListItems, vehicles, vehicleMaintenance, gpsTracking, geofences, vehicleAssignments, geofenceAlerts, gpsSessions,
  roles, permissions, rolePermissions, userRoles,
  type User, type InsertUser, type Category, type InsertCategory, type Supplier, type InsertSupplier,
  type Warehouse, type InsertWarehouse, type Product, type InsertProduct, type Inventory, type InsertInventory,
  type StockMovement, type InsertStockMovement, type Order, type InsertOrder, type OrderItem, type InsertOrderItem,
  type Shipment, type InsertShipment, type ProductLocation, type InsertProductLocation,
  type InventoryCount, type InsertInventoryCount, type InventoryCountItem, type InsertInventoryCountItem,
  type BarcodeScan, type InsertBarcodeScan,
  type PickingList, type InsertPickingList, type PickingListItem, type InsertPickingListItem,
  type Vehicle, type InsertVehicle, type VehicleMaintenance, type InsertVehicleMaintenance,
  type GpsTracking, type InsertGpsTracking, type Geofence, type InsertGeofence,
  type VehicleAssignment, type InsertVehicleAssignment, type GeofenceAlert, type InsertGeofenceAlert,
  type GpsSession, type InsertGpsSession, type Role, type InsertRole, type Permission, type InsertPermission,
  type RolePermission, type InsertRolePermission, type UserRole, type InsertUserRole
} from "../../shared/schema";

// Tipos temporários para Returns até serem implementados no schema
type Return = {
  id: string;
  orderId: string;
  returnNumber: string;
  reason: string;
  status: string;
  totalAmount: string;
  createdAt: Date;
  updatedAt: Date;
};

type InsertReturn = Omit<Return, 'id' | 'createdAt' | 'updatedAt'>;

type ReturnItem = {
  id: string;
  returnId: string;
  productId: string;
  quantity: number;
  unitPrice: string;
  totalPrice: string;
  condition: string;
  createdAt: Date;
};

type InsertReturnItem = Omit<ReturnItem, 'id' | 'createdAt'>;
import { db } from "../database/db";
import { eq, desc, sql, and, ilike, sum } from "drizzle-orm";

export interface IStorage {
  // Users
  getUsers(): Promise<User[]>;
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: string, user: Partial<InsertUser>): Promise<User>;
  deleteUser(id: string): Promise<void>;
  
  // Dashboard
  getDashboardStats(): Promise<{
    totalProducts: number;
    lowStock: number;
    pendingOrders: number;
    monthlySales: string;
  }>;
  getTopProducts(): Promise<Array<Product & { stock: number; sales: number }>>;
  getRecentActivities(): Promise<Array<StockMovement & { product: Product; user?: User | null }>>;
  
  // Categories
  getCategories(): Promise<Category[]>;
  createCategory(category: InsertCategory): Promise<Category>;
  updateCategory(id: string, category: Partial<InsertCategory>): Promise<Category>;
  deleteCategory(id: string): Promise<void>;
  
  // Suppliers
  getSuppliers(): Promise<Supplier[]>;
  createSupplier(supplier: InsertSupplier): Promise<Supplier>;
  updateSupplier(id: string, supplier: Partial<InsertSupplier>): Promise<Supplier>;
  deleteSupplier(id: string): Promise<void>;
  
  // Warehouses
  getWarehouses(): Promise<Warehouse[]>;
  createWarehouse(warehouse: InsertWarehouse): Promise<Warehouse>;
  updateWarehouse(id: string, warehouse: Partial<InsertWarehouse>): Promise<Warehouse>;
  deleteWarehouse(id: string): Promise<void>;
  
  // Products
  getProducts(): Promise<Array<Product & { category?: Category | null; supplier?: Supplier | null }>>;
  getProduct(id: string): Promise<Product | undefined>;
  searchProducts(query: string): Promise<Product[]>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product>;
  deleteProduct(id: string): Promise<void>;
  
  // Inventory
  getLowStockProducts(): Promise<Array<Product & { stock: number; category?: Category | null }>>;
  getInventoryByWarehouse(warehouseId: string): Promise<Array<Inventory & { product: Product }>>;
  getProductInventory(productId: string): Promise<Array<Inventory & { warehouse: Warehouse }>>;
  updateInventory(productId: string, warehouseId: string, quantity: number): Promise<Inventory>;
  
  // Stock Movements
  getStockMovements(limit?: number): Promise<Array<StockMovement & { product: Product; warehouse: Warehouse; user?: User | null }>>;
  createStockMovement(movement: InsertStockMovement): Promise<StockMovement>;
  
  // Orders
  getOrders(): Promise<Array<Order & { supplier?: Supplier | null; user?: User | null }>>;
  getOrder(id: string): Promise<Order | undefined>;
  createOrder(order: InsertOrder): Promise<Order>;
  updateOrder(id: string, order: Partial<InsertOrder>): Promise<Order>;
  deleteOrder(id: string): Promise<void>;
  
  // Order Items
  getOrderItems(orderId: string): Promise<Array<OrderItem & { product: Product }>>;
  createOrderItem(item: InsertOrderItem): Promise<OrderItem>;
  
  // Shipments
  getShipments(): Promise<Array<Shipment & { order?: Order | null; user?: User | null }>>;
  getShipmentByTrackingNumber(trackingNumber: string): Promise<(Shipment & { order?: Order | null; orderItems?: Array<OrderItem & { product: Product }> }) | undefined>;
  createShipment(shipment: InsertShipment): Promise<Shipment>;
  updateShipment(id: string, shipment: Partial<InsertShipment>): Promise<Shipment>;

  // Product Locations (RF1.5)
  getProductLocations(warehouseId?: string): Promise<Array<ProductLocation & { product: Product; warehouse: Warehouse }>>;
  getProductLocation(productId: string, warehouseId: string): Promise<ProductLocation | undefined>;
  getProductLocationById(id: string): Promise<ProductLocation | undefined>;
  createProductLocation(location: InsertProductLocation): Promise<ProductLocation>;
  updateProductLocation(id: string, location: Partial<InsertProductLocation>): Promise<ProductLocation>;
  deleteProductLocation(id: string): Promise<void>;
  bulkAssignProductLocations(data: any): Promise<{ assigned: number; failed: number }>;
  getWarehouseZones(warehouseId: string): Promise<any[]>;
  createWarehouseZone(data: any): Promise<any>;

  // Picking & Packing (RF2.4)
  getPickingLists(filters: any): Promise<any[]>;
  getPickingListById(id: string): Promise<any>;
  createPickingList(data: any): Promise<any>;
  updatePickingList(id: string, data: any): Promise<any>;
  deletePickingList(id: string): Promise<void>;
  startPicking(id: string, userId: string): Promise<any>;
  completePicking(id: string): Promise<any>;
  pickItem(itemId: string, data: any): Promise<any>;
  verifyPickedItem(itemId: string, data: any): Promise<any>;
  createPickingWave(data: any): Promise<any>;
  getPickingWave(waveId: string): Promise<any>;
  assignWaveToUser(waveId: string, userId: string): Promise<any>;
  getPackingTasks(filters: any): Promise<any[]>;
  createPackingTask(data: any): Promise<any>;
  packItems(id: string, data: any): Promise<any>;
  completePackaging(id: string): Promise<any>;
  generateShippingLabel(data: any): Promise<any>;
  getShippingInfo(id: string): Promise<any>;

  // Batch Management (RF1.3)
  getBatches(filters: any): Promise<any[]>;
  getBatchById(id: string): Promise<any>;
  getBatchByNumber(batchNumber: string): Promise<any>;
  createBatch(data: any): Promise<any>;
  updateBatch(id: string, data: any): Promise<any>;
  deleteBatch(id: string): Promise<void>;
  addProductsToBatch(batchId: string, data: any): Promise<any>;
  removeProductFromBatch(batchId: string, productId: string): Promise<void>;
  getBatchExpiryAlerts(batchId: string): Promise<any[]>;
  getExpiringProducts(daysAhead: number, warehouseId?: string): Promise<any[]>;
  getExpiredProducts(warehouseId?: string): Promise<any[]>;
  extendBatchExpiry(batchIds: string[], data: any): Promise<any>;
  getBatchHistory(batchNumber: string): Promise<any[]>;
  getBatchLocation(batchNumber: string): Promise<any>;

  // Inventory Counts (RF1.4)
  getInventoryCounts(warehouseId?: string): Promise<Array<InventoryCount & { warehouse: Warehouse; user?: User | null }>>;
  getInventoryCount(id: string): Promise<InventoryCount | undefined>;
  createInventoryCount(count: InsertInventoryCount): Promise<InventoryCount>;
  updateInventoryCount(id: string, count: Partial<InsertInventoryCount>): Promise<InventoryCount>;
  getInventoryCountItems(countId: string): Promise<Array<InventoryCountItem & { product: Product }>>;
  getInventoryCountItem(id: string): Promise<InventoryCountItem | undefined>;
  createInventoryCountItem(item: InsertInventoryCountItem): Promise<InventoryCountItem>;
  updateInventoryCountItem(id: string, item: Partial<InsertInventoryCountItem>): Promise<InventoryCountItem>;
  deleteInventoryCount(id: string): Promise<void>;
  generateInventoryCountList(countId: string, filters: any): Promise<InventoryCountItem[]>;
  reconcileInventoryCount(countId: string): Promise<{ reconciled: number; adjustments: any[] }>;
  completeInventoryCount(countId: string): Promise<InventoryCount>;

  // Barcode Scans (RF2.1)
  getBarcodeScans(limit?: number): Promise<Array<BarcodeScan & { product?: Product | null; warehouse?: Warehouse | null; user: User }>>;
  createBarcodeScan(scan: InsertBarcodeScan): Promise<BarcodeScan>;
  findProductByBarcode(barcode: string): Promise<Product | undefined>;
  getBarcodeScansByProduct(productId: string): Promise<Array<BarcodeScan & { warehouse?: Warehouse | null; user: User }>>;
  updateProductLastScanned(productId: string, userId: string): Promise<void>;
  updateBarcodeScanLocation(scanId: string, locationData: any): Promise<BarcodeScan>;
  getLastProductLocation(productId: string): Promise<any>;

  // Picking Lists (RF2.4)
  getPickingLists(warehouseId?: string): Promise<Array<PickingList & { warehouse: Warehouse; order?: Order | null; assignedUser?: User | null; user?: User | null }>>;
  getPickingList(id: string): Promise<(PickingList & { warehouse: Warehouse; order?: Order | null; items: Array<PickingListItem & { product: Product; location?: ProductLocation | null }> }) | undefined>;
  createPickingList(pickingList: InsertPickingList): Promise<PickingList>;
  updatePickingList(id: string, pickingList: Partial<InsertPickingList>): Promise<PickingList>;
  deletePickingList(id: string): Promise<void>;
  getPickingListItems(pickingListId: string): Promise<Array<PickingListItem & { product: Product; location?: ProductLocation | null }>>;
  createPickingListItem(item: InsertPickingListItem): Promise<PickingListItem>;
  updatePickingListItem(id: string, item: Partial<InsertPickingListItem>): Promise<PickingListItem>;

  // Advanced Reports
  getInventoryTurnoverReport(filters: {
    startDate: Date;
    endDate: Date;
    warehouseId?: string;
    categoryId?: string;
  }): Promise<any[]>;
  getObsoleteInventoryReport(filters: {
    daysWithoutMovement: number;
    warehouseId?: string;
    minValue: number;
  }): Promise<any[]>;
  getProductPerformanceReport(filters: {
    startDate: Date;
    endDate: Date;
    limit?: number;
  }): Promise<any[]>;
  getWarehouseEfficiencyReport(warehouseId?: string): Promise<any>;
  getStockValuationReport(warehouseId?: string): Promise<any>;
  getSupplierPerformanceReport(filters: {
    startDate: Date;
    endDate: Date;
    supplierId?: string;
  }): Promise<any[]>;

  // Fleet Management - Vehicles
  getVehicles(): Promise<Array<Vehicle & { driver?: User | null }>>;
  getVehicle(id: string): Promise<Vehicle | undefined>;
  getVehicleByLicensePlate(licensePlate: string): Promise<Vehicle | undefined>;
  createVehicle(vehicle: InsertVehicle): Promise<Vehicle>;
  updateVehicle(id: string, vehicle: Partial<InsertVehicle>): Promise<Vehicle>;
  deleteVehicle(id: string): Promise<void>;
  getVehiclesByStatus(status: string): Promise<Vehicle[]>;
  getAvailableVehicles(): Promise<Vehicle[]>;

  // Vehicle Maintenance
  getVehicleMaintenance(vehicleId: string): Promise<Array<VehicleMaintenance & { vehicle: Vehicle; performedByUser?: User | null }>>;
  createVehicleMaintenance(maintenance: InsertVehicleMaintenance): Promise<VehicleMaintenance>;
  updateVehicleMaintenance(id: string, maintenance: Partial<InsertVehicleMaintenance>): Promise<VehicleMaintenance>;
  getUpcomingMaintenance(): Promise<Array<VehicleMaintenance & { vehicle: Vehicle }>>;

  // GPS Tracking
  createGpsTracking(tracking: InsertGpsTracking): Promise<GpsTracking>;
  getVehicleCurrentLocation(vehicleId: string): Promise<GpsTracking | undefined>;
  getVehicleGpsHistory(vehicleId: string, hours?: number): Promise<GpsTracking[]>;
  getAllVehicleLocations(): Promise<Array<GpsTracking & { vehicle: Vehicle }>>;
  updateVehicleGpsStatus(vehicleId: string, isActive: boolean): Promise<void>;

  // Vehicle Assignments
  getVehicleAssignments(): Promise<Array<VehicleAssignment & { vehicle: Vehicle; driver: User; order?: Order | null; shipment?: Shipment | null }>>;
  getVehicleAssignment(id: string): Promise<VehicleAssignment | undefined>;
  createVehicleAssignment(assignment: InsertVehicleAssignment): Promise<VehicleAssignment>;
  updateVehicleAssignment(id: string, assignment: Partial<InsertVehicleAssignment>): Promise<VehicleAssignment>;
  getActiveAssignmentsByVehicle(vehicleId: string): Promise<VehicleAssignment[]>;
  getActiveAssignmentsByDriver(driverId: string): Promise<VehicleAssignment[]>;

  // Geofences
  getGeofences(): Promise<Array<Geofence & { warehouse?: Warehouse | null; createdBy?: User | null }>>;
  getGeofence(id: string): Promise<Geofence | undefined>;
  createGeofence(geofence: InsertGeofence): Promise<Geofence>;
  updateGeofence(id: string, geofence: Partial<InsertGeofence>): Promise<Geofence>;
  deleteGeofence(id: string): Promise<void>;
  getActiveGeofences(): Promise<Geofence[]>;

  // Geofence Alerts
  getGeofenceAlerts(): Promise<Array<GeofenceAlert & { vehicle: Vehicle; geofence: Geofence; driver?: User | null }>>;
  createGeofenceAlert(alert: InsertGeofenceAlert): Promise<GeofenceAlert>;
  acknowledgeGeofenceAlert(id: string, acknowledgedBy: string): Promise<GeofenceAlert>;
  getActiveGeofenceAlerts(): Promise<GeofenceAlert[]>;

  // GPS Sessions
  createGpsSession(session: InsertGpsSession): Promise<GpsSession>;
  updateGpsSession(id: string, session: Partial<InsertGpsSession>): Promise<GpsSession>;
  getActiveGpsSessions(): Promise<Array<GpsSession & { user: User; vehicle?: Vehicle | null }>>;
  endGpsSession(sessionId: string): Promise<GpsSession>;

  // RBAC - Roles
  getRoles(): Promise<Array<Role & { _count?: { permissions: number; users: number } }>>;
  getRole(id: string): Promise<Role | undefined>;
  createRole(role: InsertRole): Promise<Role>;
  updateRole(id: string, role: Partial<InsertRole>): Promise<Role>;
  deleteRole(id: string): Promise<void>;

  // RBAC - Permissions
  getPermissions(): Promise<Permission[]>;
  getPermission(id: string): Promise<Permission | undefined>;
  createPermission(permission: InsertPermission): Promise<Permission>;
  updatePermission(id: string, permission: Partial<InsertPermission>): Promise<Permission>;
  deletePermission(id: string): Promise<void>;
  getPermissionsByModule(module: string): Promise<Permission[]>;

  // RBAC - Role Permissions
  getRolePermissions(roleId: string): Promise<Array<Permission>>;
  addPermissionToRole(data: InsertRolePermission): Promise<RolePermission>;
  removePermissionFromRole(roleId: string, permissionId: string): Promise<void>;
  setRolePermissions(roleId: string, permissionIds: string[]): Promise<void>;

  // RBAC - User Roles
  getUserRoles(userId: string): Promise<Array<Role>>;
  getUsersWithRole(roleId: string): Promise<Array<User>>;
  addRoleToUser(data: InsertUserRole): Promise<UserRole>;
  removeRoleFromUser(userId: string, roleId: string): Promise<void>;
  setUserRoles(userId: string, roleIds: string[]): Promise<void>;
  getUserPermissions(userId: string): Promise<Array<Permission>>;
  hasPermission(userId: string, permission: string): Promise<boolean>;
}

export class DatabaseStorage implements IStorage {
  // Users
  async getUsers(): Promise<User[]> {
    return await db.select().from(users).orderBy(desc(users.createdAt));
  }

  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    await db.insert(users).values(insertUser);
    const [user] = await db.select().from(users).where(eq(users.username, insertUser.username)).limit(1);
    if (!user) {
      throw new Error('Falha ao criar utilizador');
    }
    return user;
  }

  async updateUser(id: string, updateData: Partial<InsertUser>): Promise<User> {
    await db.update(users).set(updateData).where(eq(users.id, id));
    const [user] = await db.select().from(users).where(eq(users.id, id)).limit(1);
    if (!user) {
      throw new Error('Utilizador não encontrado');
    }
    return user;
  }

  async deleteUser(id: string): Promise<void> {
    await db.delete(users).where(eq(users.id, id));
  }

  // Dashboard
  async getDashboardStats() {
    try {
      // Get real data from database
      const [totalProductsResult] = await db.select({ count: sql<number>`count(*)` }).from(products);
      const totalProducts = totalProductsResult.count || 0;
      
      const [pendingOrdersResult] = await db.select({ count: sql<number>`count(*)` }).from(orders).where(eq(orders.status, 'pending'));
      const pendingOrders = pendingOrdersResult.count || 0;
      
      // Count products with stock below minimum level
      const lowStockProducts = await db.select({ count: sql<number>`count(*)` })
        .from(products)
        .leftJoin(inventory, eq(products.id, inventory.productId))
        .where(sql`${inventory.quantity} < ${products.minStockLevel}`);
      const lowStock = lowStockProducts[0]?.count || 0;
      
      // Calculate monthly sales from completed orders this month
      const currentMonth = new Date();
      currentMonth.setDate(1);
      const currentMonthStr = currentMonth.toISOString();
      const [salesResult] = await db.select({ total: sql<string>`sum(${orders.totalAmount})` })
        .from(orders)
        .where(and(eq(orders.status, 'completed'), sql`${orders.createdAt} >= ${currentMonthStr}`));
      const monthlySales = `AOA ${Number(salesResult.total || 0).toLocaleString('pt-AO')}`;
      
      return {
        totalProducts,
        lowStock,
        pendingOrders,
        monthlySales,
      };
    } catch (error) {
      console.error('Dashboard stats error:', error);
      return {
        totalProducts: 0,
        lowStock: 0,
        pendingOrders: 0,
        monthlySales: 'AOA 0',
      };
    }
  }

  async getTopProducts() {
    try {
      // Get products with highest sales from order items
      return await db.select({
        id: products.id,
        name: products.name,
        description: products.description,
        sku: products.sku,
        barcode: products.barcode,
        price: products.price,
        weight: products.weight,
        dimensions: products.dimensions,
        categoryId: products.categoryId,
        supplierId: products.supplierId,
        minStockLevel: products.minStockLevel,
        isActive: products.isActive,
        createdAt: products.createdAt,
        stock: sql<number>`COALESCE(sum(${inventory.quantity}), 0)`,
        sales: sql<number>`COALESCE(sum(${orderItems.quantity}), 0)`
      })
        .from(products)
        .leftJoin(inventory, eq(products.id, inventory.productId))
        .leftJoin(orderItems, eq(products.id, orderItems.productId))
        .groupBy(products.id)
        .orderBy(desc(sql<number>`COALESCE(sum(${orderItems.quantity}), 0)`))
        .limit(5);
    } catch (error) {
      console.error('Top products error:', error);
      return [];
    }
  }

  async getRecentActivities() {
    try {
      const results = await db.select({
        id: stockMovements.id,
        productId: stockMovements.productId,
        warehouseId: stockMovements.warehouseId,
        userId: stockMovements.userId,
        type: stockMovements.type,
        quantity: stockMovements.quantity,
        reference: stockMovements.reference,
        reason: stockMovements.reason,
        createdAt: stockMovements.createdAt,
        product: products,
        warehouse: warehouses,
        user: users
      })
        .from(stockMovements)
        .leftJoin(products, eq(stockMovements.productId, products.id))
        .leftJoin(warehouses, eq(stockMovements.warehouseId, warehouses.id))
        .leftJoin(users, eq(stockMovements.userId, users.id))
        .orderBy(desc(stockMovements.createdAt))
        .limit(10);
      
      return results.map((row: any) => ({
        id: row.id,
        productId: row.productId,
        warehouseId: row.warehouseId,
        userId: row.userId,
        type: row.type,
        quantity: row.quantity,
        reference: row.reference,
        reason: row.reason,
        createdAt: row.createdAt,
        product: row.product!,
        warehouse: row.warehouse!,
        user: row.user
      }));
    } catch (error) {
      console.error('Recent activities error:', error);
      return [];
    }
  }

  // Categories
  async getCategories(): Promise<Category[]> {
    try {
      return await db.select().from(categories).orderBy(desc(categories.createdAt));
    } catch (error) {
      console.error('Categories error:', error);
      return [];
    }
  }

  async createCategory(category: InsertCategory): Promise<Category> {
    await db.insert(categories).values(category);
    const insertedCategory = await db.select().from(categories).where(eq(categories.name, category.name)).limit(1);
    return insertedCategory[0];
  }

  async updateCategory(id: string, category: Partial<InsertCategory>): Promise<Category> {
    await db.update(categories).set(category).where(eq(categories.id, id));
    const [result] = await db.select().from(categories).where(eq(categories.id, id)).limit(1);
    return result;
  }

  async deleteCategory(id: string): Promise<void> {
    await db.delete(categories).where(eq(categories.id, id));
  }

  // Suppliers
  async getSuppliers(): Promise<Supplier[]> {
    try {
      return await db.select().from(suppliers).orderBy(desc(suppliers.createdAt));
    } catch (error) {
      console.error('Suppliers error:', error);
      return [];
    }
  }

  async createSupplier(supplier: InsertSupplier): Promise<Supplier> {
    await db.insert(suppliers).values(supplier);
    const insertedSupplier = await db.select().from(suppliers).where(eq(suppliers.name, supplier.name)).limit(1);
    return insertedSupplier[0];
  }

  async updateSupplier(id: string, supplier: Partial<InsertSupplier>): Promise<Supplier> {
    await db.update(suppliers).set(supplier).where(eq(suppliers.id, id));
    const [result] = await db.select().from(suppliers).where(eq(suppliers.id, id)).limit(1);
    return result;
  }

  async deleteSupplier(id: string): Promise<void> {
    await db.delete(suppliers).where(eq(suppliers.id, id));
  }

  // Warehouses
  async getWarehouses(): Promise<Warehouse[]> {
    return await db.select().from(warehouses).orderBy(warehouses.name);
  }

  async createWarehouse(warehouse: InsertWarehouse): Promise<Warehouse> {
    await db.insert(warehouses).values(warehouse);
    const insertedWarehouse = await db.select().from(warehouses).where(eq(warehouses.name, warehouse.name)).limit(1);
    return insertedWarehouse[0];
  }

  async updateWarehouse(id: string, warehouse: Partial<InsertWarehouse>): Promise<Warehouse> {
    await db.update(warehouses).set(warehouse).where(eq(warehouses.id, id));
    const [result] = await db.select().from(warehouses).where(eq(warehouses.id, id)).limit(1);
    return result;
  }

  async deleteWarehouse(id: string): Promise<void> {
    await db.delete(warehouses).where(eq(warehouses.id, id));
  }

  // Products
  async getProducts(): Promise<Array<Product & { category?: Category | null; supplier?: Supplier | null }>> {
    try {
      return await db.select()
        .from(products)
        .leftJoin(categories, eq(products.categoryId, categories.id))
        .leftJoin(suppliers, eq(products.supplierId, suppliers.id))
        .orderBy(desc(products.createdAt))
        .then((results: any[]) => 
          results.map((row: any) => ({
            ...row.products,
            category: row.categories,
            supplier: row.suppliers
          }))
        );
    } catch (error) {
      console.error('Products error:', error);
      return [];
    }
  }

  async getProduct(id: string): Promise<Product | undefined> {
    const [result] = await db.select().from(products).where(eq(products.id, id));
    return result || undefined;
  }

  async searchProducts(query: string): Promise<Product[]> {
    return await db
      .select()
      .from(products)
      .where(
        and(
          eq(products.isActive, true),
          sql`${products.name} ILIKE ${`%${query}%`} OR ${products.sku} ILIKE ${`%${query}%`}`
        )
      )
      .limit(10);
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    await db.insert(products).values(product);
    const insertedProduct = await db.select().from(products).where(eq(products.sku, product.sku)).limit(1);
    return insertedProduct[0];
  }

  async updateProduct(id: string, product: Partial<InsertProduct>): Promise<Product> {
    await db.update(products).set(product).where(eq(products.id, id));
    const [result] = await db.select().from(products).where(eq(products.id, id)).limit(1);
    return result;
  }

  async deleteProduct(id: string): Promise<void> {
    await db.update(products).set({ isActive: false }).where(eq(products.id, id));
  }

  // Inventory
  async getLowStockProducts() {
    try {
      return await db.select({
        id: products.id,
        name: products.name,
        description: products.description,
        sku: products.sku,
        barcode: products.barcode,
        price: products.price,
        weight: products.weight,
        dimensions: products.dimensions,
        categoryId: products.categoryId,
        supplierId: products.supplierId,
        minStockLevel: products.minStockLevel,
        isActive: products.isActive,
        createdAt: products.createdAt,
        stock: sql<number>`COALESCE(sum(${inventory.quantity}), 0)`,
        category: categories
      })
        .from(products)
        .leftJoin(categories, eq(products.categoryId, categories.id))
        .leftJoin(inventory, eq(products.id, inventory.productId))
        .groupBy(products.id, categories.id)
        .having(sql`COALESCE(sum(${inventory.quantity}), 0) < ${products.minStockLevel}`)
        .orderBy(sql`COALESCE(sum(${inventory.quantity}), 0)`);
    } catch (error) {
      console.error('Low stock products error:', error);
      return [];
    }
  }

  async getInventoryByWarehouse(warehouseId: string) {
    return await db
      .select({
        id: inventory.id,
        productId: inventory.productId,
        warehouseId: inventory.warehouseId,
        quantity: inventory.quantity,
        reservedQuantity: inventory.reservedQuantity,
        lastUpdated: inventory.lastUpdated,
        product: products
      })
      .from(inventory)
      .innerJoin(products, eq(inventory.productId, products.id))
      .where(eq(inventory.warehouseId, warehouseId));
  }

  async getProductInventory(productId: string) {
    return await db
      .select({
        id: inventory.id,
        productId: inventory.productId,
        warehouseId: inventory.warehouseId,
        quantity: inventory.quantity,
        reservedQuantity: inventory.reservedQuantity,
        lastUpdated: inventory.lastUpdated,
        warehouse: warehouses
      })
      .from(inventory)
      .innerJoin(warehouses, eq(inventory.warehouseId, warehouses.id))
      .where(eq(inventory.productId, productId));
  }

  async updateInventory(productId: string, warehouseId: string, quantity: number): Promise<Inventory> {
    const [existing] = await db
      .select()
      .from(inventory)
      .where(and(eq(inventory.productId, productId), eq(inventory.warehouseId, warehouseId)));

    if (existing) {
      await db
        .update(inventory)
        .set({ quantity, lastUpdated: new Date() })
        .where(eq(inventory.id, existing.id));
      const [result] = await db.select().from(inventory).where(eq(inventory.id, existing.id));
      return result;
    } else {
      const newInventory = { productId, warehouseId, quantity };
      await db.insert(inventory).values(newInventory);
      const [result] = await db.select().from(inventory)
        .where(and(eq(inventory.productId, productId), eq(inventory.warehouseId, warehouseId)));
      return result;
    }
  }

  // Stock Movements
  async getStockMovements(limit = 50) {
    return await db
      .select({
        id: stockMovements.id,
        productId: stockMovements.productId,
        warehouseId: stockMovements.warehouseId,
        type: stockMovements.type,
        quantity: stockMovements.quantity,
        reference: stockMovements.reference,
        reason: stockMovements.reason,
        userId: stockMovements.userId,
        createdAt: stockMovements.createdAt,
        product: products,
        warehouse: warehouses,
        user: users
      })
      .from(stockMovements)
      .innerJoin(products, eq(stockMovements.productId, products.id))
      .innerJoin(warehouses, eq(stockMovements.warehouseId, warehouses.id))
      .leftJoin(users, eq(stockMovements.userId, users.id))
      .orderBy(desc(stockMovements.createdAt))
      .limit(limit);
  }

  async createStockMovement(movement: InsertStockMovement): Promise<StockMovement> {
    await db.insert(stockMovements).values(movement);
    const [result] = await db.select().from(stockMovements)
      .where(and(
        eq(stockMovements.productId, movement.productId),
        eq(stockMovements.warehouseId, movement.warehouseId)
      ))
      .orderBy(desc(stockMovements.createdAt))
      .limit(1);
    return result;
  }

  // Orders
  async getOrders() {
    return await db
      .select({
        id: orders.id,
        createdAt: orders.createdAt,
        notes: orders.notes,
        supplierId: orders.supplierId,
        type: orders.type,
        userId: orders.userId,
        orderNumber: orders.orderNumber,
        status: orders.status,
        customerId: orders.customerId,
        customerName: orders.customerName,
        customerEmail: orders.customerEmail,
        customerPhone: orders.customerPhone,
        customerAddress: orders.customerAddress,
        totalAmount: orders.totalAmount,
        supplier: suppliers,
        user: users
      })
      .from(orders)
      .leftJoin(suppliers, eq(orders.supplierId, suppliers.id))
      .leftJoin(users, eq(orders.userId, users.id))
      .orderBy(desc(orders.createdAt));
  }

  async getOrder(id: string): Promise<Order | undefined> {
    const [result] = await db.select().from(orders).where(eq(orders.id, id));
    return result || undefined;
  }

  async createOrder(order: InsertOrder): Promise<Order> {
    await db.insert(orders).values(order);
    const [result] = await db.select().from(orders)
      .where(eq(orders.orderNumber, order.orderNumber))
      .orderBy(desc(orders.createdAt))
      .limit(1);
    return result;
  }

  async updateOrder(id: string, order: Partial<InsertOrder>): Promise<Order> {
    await db
      .update(orders)
      .set(order)
      .where(eq(orders.id, id));
    const [result] = await db.select().from(orders).where(eq(orders.id, id));
    return result;
  }

  async deleteOrder(id: string): Promise<void> {
    await db.delete(orders).where(eq(orders.id, id));
  }

  // Order Items
  async getOrderItems(orderId: string) {
    return await db
      .select({
        id: orderItems.id,
        orderId: orderItems.orderId,
        productId: orderItems.productId,
        quantity: orderItems.quantity,
        unitPrice: orderItems.unitPrice,
        totalPrice: orderItems.totalPrice,
        product: products
      })
      .from(orderItems)
      .innerJoin(products, eq(orderItems.productId, products.id))
      .where(eq(orderItems.orderId, orderId));
  }

  async createOrderItem(item: InsertOrderItem): Promise<OrderItem> {
    await db.insert(orderItems).values(item);
    const [result] = await db.select().from(orderItems)
      .where(and(
        eq(orderItems.orderId, item.orderId),
        eq(orderItems.productId, item.productId)
      ))
      .orderBy(desc(orderItems.id))
      .limit(1);
    return result;
  }

  // Shipments
  async getShipments() {
    return await db
      .select({
        id: shipments.id,
        createdAt: shipments.createdAt,
        userId: shipments.userId,
        status: shipments.status,
        orderId: shipments.orderId,
        shipmentNumber: shipments.shipmentNumber,
        vehicleId: shipments.vehicleId,
        carrier: shipments.carrier,
        trackingNumber: shipments.trackingNumber,
        shippingAddress: shipments.shippingAddress,
        estimatedDelivery: shipments.estimatedDelivery,
        actualDelivery: shipments.actualDelivery,
        order: orders,
        user: users
      })
      .from(shipments)
      .leftJoin(orders, eq(shipments.orderId, orders.id))
      .leftJoin(users, eq(shipments.userId, users.id))
      .orderBy(desc(shipments.createdAt));
  }

  async createShipment(shipment: InsertShipment): Promise<Shipment> {
    await db.insert(shipments).values(shipment);
    const [result] = await db.select().from(shipments)
      .where(eq(shipments.shipmentNumber, shipment.shipmentNumber))
      .orderBy(desc(shipments.createdAt))
      .limit(1);
    return result;
  }

  async updateShipment(id: string, shipment: Partial<InsertShipment>): Promise<Shipment> {
    await db
      .update(shipments)
      .set(shipment)
      .where(eq(shipments.id, id));
    const [result] = await db.select().from(shipments).where(eq(shipments.id, id));
    return result;
  }

  async getShipmentByTrackingNumber(trackingNumber: string) {
    const [shipment] = await db
      .select({
        id: shipments.id,
        createdAt: shipments.createdAt,
        userId: shipments.userId,
        status: shipments.status,
        orderId: shipments.orderId,
        shipmentNumber: shipments.shipmentNumber,
        vehicleId: shipments.vehicleId,
        carrier: shipments.carrier,
        trackingNumber: shipments.trackingNumber,
        shippingAddress: shipments.shippingAddress,
        estimatedDelivery: shipments.estimatedDelivery,
        actualDelivery: shipments.actualDelivery,
        order: orders,
        user: users
      })
      .from(shipments)
      .leftJoin(orders, eq(shipments.orderId, orders.id))
      .leftJoin(users, eq(shipments.userId, users.id))
      .where(eq(shipments.trackingNumber, trackingNumber));

    return shipment;
  }

  // Product Locations (RF1.5)
  async getProductLocations(warehouseId?: string) {
    const query = db
      .select({
        id: productLocations.id,
        productId: productLocations.productId,
        warehouseId: productLocations.warehouseId,
        zone: productLocations.zone,
        shelf: productLocations.shelf,
        bin: productLocations.bin,
        lastScanned: productLocations.lastScanned,
        scannedByUserId: productLocations.scannedByUserId,
        createdAt: productLocations.createdAt,
        product: products,
        warehouse: warehouses
      })
      .from(productLocations)
      .innerJoin(products, eq(productLocations.productId, products.id))
      .innerJoin(warehouses, eq(productLocations.warehouseId, warehouses.id));

    if (warehouseId) {
      query.where(eq(productLocations.warehouseId, warehouseId));
    }

    return await query.orderBy(desc(productLocations.createdAt));
  }

  async getProductLocation(productId: string, warehouseId: string) {
    const [location] = await db
      .select()
      .from(productLocations)
      .where(and(
        eq(productLocations.productId, productId),
        eq(productLocations.warehouseId, warehouseId)
      ));
    return location || undefined;
  }

  async createProductLocation(location: InsertProductLocation): Promise<ProductLocation> {
    await db.insert(productLocations).values(location);
    const [result] = await db.select().from(productLocations)
      .where(and(
        eq(productLocations.productId, location.productId),
        eq(productLocations.warehouseId, location.warehouseId)
      ))
      .orderBy(desc(productLocations.id))
      .limit(1);
    return result;
  }

  async updateProductLocation(id: string, location: Partial<InsertProductLocation>): Promise<ProductLocation> {
    await db
      .update(productLocations)
      .set(location)
      .where(eq(productLocations.id, id));
    const [result] = await db.select().from(productLocations).where(eq(productLocations.id, id));
    return result;
  }

  async deleteProductLocation(id: string): Promise<void> {
    await db.delete(productLocations).where(eq(productLocations.id, id));
  }

  async getProductLocationById(id: string): Promise<ProductLocation | undefined> {
    const [location] = await db
      .select()
      .from(productLocations)
      .where(eq(productLocations.id, id));
    return location || undefined;
  }

  async bulkAssignProductLocations(data: {
    productIds: string[];
    warehouseId: string;
    zone: string;
    autoAssignBins: boolean;
  }): Promise<{ assigned: number; failed: number }> {
    let assigned = 0;
    let failed = 0;
    
    for (const productId of data.productIds) {
      try {
        const bin = data.autoAssignBins ? `BIN-${Math.random().toString(36).substr(2, 9)}` : undefined;
        
        await db.insert(productLocations).values({
          productId,
          warehouseId: data.warehouseId,
          zone: data.zone,
          bin
        });
        assigned++;
      } catch (error) {
        console.error(`Failed to assign location for product ${productId}:`, error);
        failed++;
      }
    }
    
    return { assigned, failed };
  }

  async getWarehouseZones(warehouseId: string): Promise<any[]> {
    // Get unique zones from product locations
    const zones = await db
      .selectDistinct({ zone: productLocations.zone })
      .from(productLocations)
      .where(eq(productLocations.warehouseId, warehouseId));
    
    return zones.map((z: any) => ({ 
      zoneName: z.zone,
      warehouseId,
      productCount: 0 // TODO: Count products in each zone
    }));
  }

  async createWarehouseZone(data: {
    warehouseId: string;
    zoneName: string;
    description?: string;
    maxCapacity?: number;
  }): Promise<any> {
    // For now, just return the zone data
    // In a full implementation, we'd create a separate warehouse_zones table
    return {
      id: `zone-${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date()
    };
  }

  // Picking & Packing Implementation
  async getPickingLists(filters: any): Promise<any[]> {
    try {
      return [
        {
          id: '1',
          orderNumbers: ['ORD-001', 'ORD-002'],
          warehouseId: filters?.warehouseId || 'wh-1',
          status: 'pending',
          priority: 'normal',
          createdAt: new Date().toISOString()
        }
      ];
    } catch (error) {
      console.error('Error getting picking lists:', error);
      return [];
    }
  }

  async getPickingListById(id: string): Promise<any> {
    try {
      return {
        id,
        orderNumbers: ['ORD-001'],
        warehouseId: 'wh-1',
        status: 'pending',
        priority: 'normal',
        items: [],
        createdAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error getting picking list:', error);
      return null;
    }
  }

  async createPickingList(data: any): Promise<any> {
    try {
      return {
        id: `pl-${Math.random().toString(36).substr(2, 9)}`,
        ...data,
        status: 'pending',
        createdAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error creating picking list:', error);
      throw error;
    }
  }

  async updatePickingList(id: string, data: any): Promise<any> {
    try {
      return {
        id,
        ...data,
        updatedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error updating picking list:', error);
      throw error;
    }
  }

  async deletePickingList(id: string): Promise<void> {
    try {
      console.log(`Deleting picking list ${id}`);
    } catch (error) {
      console.error('Error deleting picking list:', error);
      throw error;
    }
  }

  async startPicking(id: string, userId: string): Promise<any> {
    return {
      id,
      status: 'in_progress',
      assignedToUserId: userId,
      startedAt: new Date()
    };
  }

  async completePicking(id: string): Promise<any> {
    return {
      id,
      status: 'completed',
      completedAt: new Date()
    };
  }

  async pickItem(itemId: string, data: any): Promise<any> {
    return {
      itemId,
      ...data,
      status: 'picked'
    };
  }

  async verifyPickedItem(itemId: string, data: any): Promise<any> {
    return {
      itemId,
      ...data,
      verified: true
    };
  }

  async createPickingWave(data: any): Promise<any> {
    return {
      id: `wave-${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      status: 'active'
    };
  }

  async getPickingWave(waveId: string): Promise<any> {
    return {
      id: waveId,
      pickingLists: [],
      status: 'active'
    };
  }

  async assignWaveToUser(waveId: string, userId: string): Promise<any> {
    return {
      waveId,
      assignedToUserId: userId,
      assignedAt: new Date()
    };
  }

  async getPackingTasks(filters: any): Promise<any[]> {
    return [
      {
        id: '1',
        pickingListId: 'pl-1',
        status: 'pending',
        packageType: 'box',
        createdAt: new Date()
      }
    ];
  }

  async createPackingTask(data: any): Promise<any> {
    return {
      id: `pt-${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      status: 'pending',
      createdAt: new Date()
    };
  }

  async packItems(id: string, data: any): Promise<any> {
    return {
      id,
      ...data,
      status: 'packed',
      packedAt: new Date()
    };
  }

  async completePackaging(id: string): Promise<any> {
    return {
      id,
      status: 'completed',
      completedAt: new Date()
    };
  }

  async generateShippingLabel(data: any): Promise<any> {
    return {
      id: `label-${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      trackingNumber: `TRK-${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
      labelUrl: '/api/shipping-labels/download',
      createdAt: new Date()
    };
  }

  async getShippingInfo(id: string): Promise<any> {
    return {
      pickingListId: id,
      trackingNumber: 'TRK-ABC123',
      carrier: 'DHL',
      estimatedDelivery: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000),
      status: 'ready_to_ship'
    };
  }

  // Batch Management Implementation
  async getBatches(filters: any): Promise<any[]> {
    const now = new Date();
    const sampleBatches = [
      {
        id: '1',
        batchNumber: 'BATCH-2025-001',
        productId: 'prod-1',
        warehouseId: filters.warehouseId || 'wh-1',
        manufacturingDate: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000),
        expiryDate: new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000),
        quantity: 100,
        qualityStatus: 'approved',
        isExpiring: false
      },
      {
        id: '2',
        batchNumber: 'BATCH-2025-002',
        productId: 'prod-2',
        warehouseId: filters.warehouseId || 'wh-1',
        manufacturingDate: new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000),
        expiryDate: new Date(now.getTime() + 15 * 24 * 60 * 60 * 1000),
        quantity: 50,
        qualityStatus: 'approved',
        isExpiring: true
      }
    ];
    
    return filters.expiryAlert ? sampleBatches.filter(b => b.isExpiring) : sampleBatches;
  }

  async getBatchById(id: string): Promise<any> {
    return {
      id,
      batchNumber: `BATCH-2025-${id.padStart(3, '0')}`,
      productId: 'prod-1',
      warehouseId: 'wh-1',
      manufacturingDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      expiryDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000),
      quantity: 100,
      qualityStatus: 'approved',
      supplierBatchRef: 'SUP-BATCH-001',
      notes: 'Lote em boas condições'
    };
  }

  async getBatchByNumber(batchNumber: string): Promise<any> {
    return {
      id: '1',
      batchNumber,
      productId: 'prod-1',
      warehouseId: 'wh-1',
      manufacturingDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      expiryDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000),
      quantity: 100,
      qualityStatus: 'approved'
    };
  }

  async createBatch(data: any): Promise<any> {
    return {
      id: `batch-${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date()
    };
  }

  async updateBatch(id: string, data: any): Promise<any> {
    return {
      id,
      ...data,
      updatedAt: new Date()
    };
  }

  async deleteBatch(id: string): Promise<void> {
    // Mock deletion
  }

  async addProductsToBatch(batchId: string, data: any): Promise<any> {
    return {
      batchId,
      productsAdded: data.productIds.length,
      totalQuantity: data.quantity
    };
  }

  async removeProductFromBatch(batchId: string, productId: string): Promise<void> {
    // Mock removal
  }

  async getBatchExpiryAlerts(batchId: string): Promise<any[]> {
    return [
      {
        type: 'warning',
        message: 'Lote expira em 15 dias',
        daysUntilExpiry: 15,
        severity: 'medium'
      }
    ];
  }

  async getExpiringProducts(daysAhead: number, warehouseId?: string): Promise<any[]> {
    return [
      {
        productId: 'prod-1',
        productName: 'Produto A',
        batchNumber: 'BATCH-2025-002',
        expiryDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000),
        quantity: 50,
        daysUntilExpiry: 15
      }
    ];
  }

  async getExpiredProducts(warehouseId?: string): Promise<any[]> {
    return [
      {
        productId: 'prod-2',
        productName: 'Produto B',
        batchNumber: 'BATCH-2025-003',
        expiryDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
        quantity: 25,
        daysExpired: 5
      }
    ];
  }

  async extendBatchExpiry(batchIds: string[], data: any): Promise<any> {
    return {
      batchesUpdated: batchIds.length,
      newExpiryDate: data.newExpiryDate,
      reason: data.reason,
      extendedBy: data.extendedByUserId
    };
  }

  async getBatchHistory(batchNumber: string): Promise<any[]> {
    return [
      {
        date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
        action: 'created',
        description: 'Lote criado',
        userId: 'user-1'
      },
      {
        date: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),
        action: 'quality_check',
        description: 'Controlo de qualidade aprovado',
        userId: 'user-2'
      }
    ];
  }

  async getBatchLocation(batchNumber: string): Promise<any> {
    return {
      batchNumber,
      warehouseId: 'wh-1',
      warehouseName: 'Armazém Principal',
      zone: 'A',
      shelf: 'A-01',
      bin: 'A-01-001',
      quantity: 100
    };
  }

  // Inventory Counts (RF1.4)
  async getInventoryCounts(warehouseId?: string) {
    const query = db
      .select({
        id: inventoryCounts.id,
        countNumber: inventoryCounts.countNumber,
        type: inventoryCounts.type,
        status: inventoryCounts.status,
        warehouseId: inventoryCounts.warehouseId,
        scheduledDate: inventoryCounts.scheduledDate,
        completedDate: inventoryCounts.completedDate,
        userId: inventoryCounts.userId,
        notes: inventoryCounts.notes,
        createdAt: inventoryCounts.createdAt,
        warehouse: warehouses,
        user: users
      })
      .from(inventoryCounts)
      .innerJoin(warehouses, eq(inventoryCounts.warehouseId, warehouses.id))
      .leftJoin(users, eq(inventoryCounts.userId, users.id));

    if (warehouseId) {
      query.where(eq(inventoryCounts.warehouseId, warehouseId));
    }

    return await query.orderBy(desc(inventoryCounts.createdAt));
  }

  async getInventoryCount(id: string) {
    const [count] = await db
      .select()
      .from(inventoryCounts)
      .where(eq(inventoryCounts.id, id));
    return count || undefined;
  }

  async createInventoryCount(count: InsertInventoryCount): Promise<InventoryCount> {
    await db.insert(inventoryCounts).values(count);
    const [insertedCount] = await db.select().from(inventoryCounts)
      .where(eq(inventoryCounts.warehouseId, count.warehouseId))
      .orderBy(desc(inventoryCounts.createdAt))
      .limit(1);
    return insertedCount;
  }

  async updateInventoryCount(id: string, count: Partial<InsertInventoryCount>): Promise<InventoryCount> {
    await db
      .update(inventoryCounts)
      .set(count)
      .where(eq(inventoryCounts.id, id));
    const [result] = await db.select().from(inventoryCounts).where(eq(inventoryCounts.id, id));
    return result;
  }

  async getInventoryCountItems(countId: string) {
    return await db
      .select({
        id: inventoryCountItems.id,
        countId: inventoryCountItems.countId,
        productId: inventoryCountItems.productId,
        expectedQuantity: inventoryCountItems.expectedQuantity,
        countedQuantity: inventoryCountItems.countedQuantity,
        variance: inventoryCountItems.variance,
        reconciled: inventoryCountItems.reconciled,
        countedByUserId: inventoryCountItems.countedByUserId,
        countedAt: inventoryCountItems.countedAt,
        product: products
      })
      .from(inventoryCountItems)
      .innerJoin(products, eq(inventoryCountItems.productId, products.id))
      .where(eq(inventoryCountItems.countId, countId));
  }

  async createInventoryCountItem(item: InsertInventoryCountItem): Promise<InventoryCountItem> {
    await db.insert(inventoryCountItems).values(item);
    const [insertedItem] = await db.select().from(inventoryCountItems)
      .where(and(
        eq(inventoryCountItems.countId, item.countId),
        eq(inventoryCountItems.productId, item.productId)
      ))
      .orderBy(desc(inventoryCountItems.id))
      .limit(1);
    return insertedItem;
  }

  async updateInventoryCountItem(id: string, item: Partial<InsertInventoryCountItem>): Promise<InventoryCountItem> {
    await db
      .update(inventoryCountItems)
      .set(item)
      .where(eq(inventoryCountItems.id, id));
    const [result] = await db.select().from(inventoryCountItems).where(eq(inventoryCountItems.id, id));
    return result;
  }

  async getInventoryCountItem(id: string): Promise<InventoryCountItem | undefined> {
    const [item] = await db
      .select()
      .from(inventoryCountItems)
      .where(eq(inventoryCountItems.id, id));
    return item || undefined;
  }

  async deleteInventoryCount(id: string): Promise<void> {
    // First delete all count items
    await db.delete(inventoryCountItems).where(eq(inventoryCountItems.countId, id));
    // Then delete the count
    await db.delete(inventoryCounts).where(eq(inventoryCounts.id, id));
  }

  async generateInventoryCountList(countId: string, filters: {
    warehouseId?: string;
    categoryId?: string;
    supplierIds?: string[];
  }): Promise<InventoryCountItem[]> {
    // Get inventory items based on filters
    const conditions = [];
    if (filters.warehouseId) {
      conditions.push(eq(inventory.warehouseId, filters.warehouseId));
    }
    if (filters.categoryId) {
      conditions.push(eq(products.categoryId, filters.categoryId));
    }
    
    const query = db
      .select({
        productId: inventory.productId,
        quantity: inventory.quantity,
        product: products
      })
      .from(inventory)
      .innerJoin(products, eq(inventory.productId, products.id))
      .where(conditions.length > 0 ? and(...conditions) : sql`1=1`);

    const inventoryItems = await query;
    
    // Create count items for each inventory item
    const countItems: InsertInventoryCountItem[] = inventoryItems.map((item: any) => ({
      countId,
      productId: item.productId,
      expectedQuantity: item.quantity
    }));

    if (countItems.length > 0) {
      await db.insert(inventoryCountItems).values(countItems);
      return await db.select().from(inventoryCountItems).where(eq(inventoryCountItems.countId, countId));
    }
    return [];
  }

  async reconcileInventoryCount(countId: string): Promise<{ reconciled: number; adjustments: any[] }> {
    // Get all count items with variances
    const countItems = await db
      .select()
      .from(inventoryCountItems)
      .where(eq(inventoryCountItems.countId, countId));

    const adjustments = [];
    let reconciled = 0;

    for (const item of countItems) {
      if (item.variance && item.variance !== 0 && item.countedQuantity !== null) {
        // Update inventory with counted quantity
        const [count] = await db
          .select({ warehouseId: inventoryCounts.warehouseId })
          .from(inventoryCounts)
          .where(eq(inventoryCounts.id, countId));

        if (count) {
          await db
            .update(inventory)
            .set({ quantity: item.countedQuantity })
            .where(
              and(
                eq(inventory.productId, item.productId),
                eq(inventory.warehouseId, count.warehouseId)
              )
            );

          // Mark as reconciled
          await db
            .update(inventoryCountItems)
            .set({ reconciled: true })
            .where(eq(inventoryCountItems.id, item.id));

          adjustments.push({
            productId: item.productId,
            expectedQuantity: item.expectedQuantity,
            countedQuantity: item.countedQuantity,
            variance: item.variance
          });
          reconciled++;
        }
      }
    }

    return { reconciled, adjustments };
  }

  async completeInventoryCount(countId: string): Promise<InventoryCount> {
    await db
      .update(inventoryCounts)
      .set({ 
        status: 'completed',
        completedDate: new Date()
      })
      .where(eq(inventoryCounts.id, countId));
    const [result] = await db.select().from(inventoryCounts).where(eq(inventoryCounts.id, countId));
    return result;
  }

  // Barcode Scans (RF2.1)
  async getBarcodeScans(limit: number = 100) {
    return await db
      .select({
        id: barcodeScans.id,
        scannedCode: barcodeScans.scannedCode,
        scanType: barcodeScans.scanType,
        productId: barcodeScans.productId,
        warehouseId: barcodeScans.warehouseId,
        locationId: barcodeScans.locationId,
        scanPurpose: barcodeScans.scanPurpose,
        userId: barcodeScans.userId,
        metadata: barcodeScans.metadata,
        createdAt: barcodeScans.createdAt,
        product: products,
        warehouse: warehouses,
        user: users
      })
      .from(barcodeScans)
      .leftJoin(products, eq(barcodeScans.productId, products.id))
      .leftJoin(warehouses, eq(barcodeScans.warehouseId, warehouses.id))
      .innerJoin(users, eq(barcodeScans.userId, users.id))
      .orderBy(desc(barcodeScans.createdAt))
      .limit(limit);
  }

  async createBarcodeScan(scan: InsertBarcodeScan): Promise<BarcodeScan> {
    await db.insert(barcodeScans).values(scan);
    const [insertedScan] = await db.select().from(barcodeScans)
      .where(and(
        eq(barcodeScans.scannedCode, scan.scannedCode),
        eq(barcodeScans.userId, scan.userId)
      ))
      .orderBy(desc(barcodeScans.createdAt))
      .limit(1);
    return insertedScan;
  }

  async findProductByBarcode(barcode: string) {
    const [product] = await db
      .select()
      .from(products)
      .where(eq(products.barcode, barcode));
    return product || undefined;
  }

  async getBarcodeScansByProduct(productId: string) {
    return await db
      .select({
        id: barcodeScans.id,
        scannedCode: barcodeScans.scannedCode,
        scanType: barcodeScans.scanType,
        productId: barcodeScans.productId,
        warehouseId: barcodeScans.warehouseId,
        locationId: barcodeScans.locationId,
        scanPurpose: barcodeScans.scanPurpose,
        userId: barcodeScans.userId,
        metadata: barcodeScans.metadata,
        createdAt: barcodeScans.createdAt,
        warehouse: warehouses,
        user: users
      })
      .from(barcodeScans)
      .leftJoin(warehouses, eq(barcodeScans.warehouseId, warehouses.id))
      .innerJoin(users, eq(barcodeScans.userId, users.id))
      .where(eq(barcodeScans.productId, productId))
      .orderBy(desc(barcodeScans.createdAt));
  }

  async updateProductLastScanned(productId: string, userId: string): Promise<void> {
    // Note: The products table doesn't have lastScanned fields yet
    // For now, we'll just track this via barcode scans
    // In a future migration, we could add lastScanned and scannedByUserId to products table
    console.log(`Product ${productId} scanned by user ${userId}`);
  }

  async updateBarcodeScanLocation(scanId: string, locationData: any): Promise<BarcodeScan> {
    await db
      .update(barcodeScans)
      .set({ 
        locationId: locationData.locationId,
        metadata: sql`${barcodeScans.metadata} || ${JSON.stringify(locationData)}`
      })
      .where(eq(barcodeScans.id, scanId));
    const [result] = await db.select().from(barcodeScans).where(eq(barcodeScans.id, scanId));
    return result;
  }

  async getLastProductLocation(productId: string) {
    const [lastScan] = await db
      .select({
        id: barcodeScans.id,
        scannedCode: barcodeScans.scannedCode,
        locationId: barcodeScans.locationId,
        warehouseId: barcodeScans.warehouseId,
        metadata: barcodeScans.metadata,
        createdAt: barcodeScans.createdAt,
        location: productLocations,
        warehouse: warehouses
      })
      .from(barcodeScans)
      .leftJoin(productLocations, eq(barcodeScans.locationId, productLocations.id))
      .leftJoin(warehouses, eq(barcodeScans.warehouseId, warehouses.id))
      .where(eq(barcodeScans.productId, productId))
      .orderBy(desc(barcodeScans.createdAt))
      .limit(1);
    return lastScan || undefined;
  }

  // Picking Lists Management (RF2.4) - Using real database implementation

  async getPickingList(id: string) {
    const [pickingListData] = await db
      .select({
        id: pickingLists.id,
        pickNumber: pickingLists.pickNumber,
        orderId: pickingLists.orderId,
        warehouseId: pickingLists.warehouseId,
        status: pickingLists.status,
        priority: pickingLists.priority,
        assignedTo: pickingLists.assignedTo,
        type: pickingLists.type,
        scheduledDate: pickingLists.scheduledDate,
        startedAt: pickingLists.startedAt,
        completedAt: pickingLists.completedAt,
        estimatedTime: pickingLists.estimatedTime,
        actualTime: pickingLists.actualTime,
        notes: pickingLists.notes,
        userId: pickingLists.userId,
        createdAt: pickingLists.createdAt,
        warehouse: warehouses,
        order: orders
      })
      .from(pickingLists)
      .innerJoin(warehouses, eq(pickingLists.warehouseId, warehouses.id))
      .leftJoin(orders, eq(pickingLists.orderId, orders.id))
      .where(eq(pickingLists.id, id));

    if (!pickingListData) {
      return undefined;
    }

    // Get picking list items
    const items = await this.getPickingListItems(id);

    return {
      ...pickingListData,
      items
    };
  }


  async getPickingListItems(pickingListId: string) {
    return await db
      .select({
        id: pickingListItems.id,
        pickingListId: pickingListItems.pickingListId,
        productId: pickingListItems.productId,
        locationId: pickingListItems.locationId,
        quantityToPick: pickingListItems.quantityToPick,
        quantityPicked: pickingListItems.quantityPicked,
        status: pickingListItems.status,
        pickedBy: pickingListItems.pickedBy,
        pickedAt: pickingListItems.pickedAt,
        notes: pickingListItems.notes,
        substitutedWith: pickingListItems.substitutedWith,
        product: products,
        location: productLocations
      })
      .from(pickingListItems)
      .innerJoin(products, eq(pickingListItems.productId, products.id))
      .leftJoin(productLocations, eq(pickingListItems.locationId, productLocations.id))
      .where(eq(pickingListItems.pickingListId, pickingListId))
      .orderBy(pickingListItems.id);
  }

  async createPickingListItem(item: InsertPickingListItem): Promise<PickingListItem> {
    await db.insert(pickingListItems).values(item);
    const [insertedItem] = await db.select().from(pickingListItems)
      .where(and(
        eq(pickingListItems.pickingListId, item.pickingListId),
        eq(pickingListItems.productId, item.productId)
      ))
      .orderBy(desc(pickingListItems.id))
      .limit(1);
    return insertedItem;
  }

  async updatePickingListItem(id: string, item: Partial<InsertPickingListItem>): Promise<PickingListItem> {
    await db
      .update(pickingListItems)
      .set(item)
      .where(eq(pickingListItems.id, id));
    const [result] = await db.select().from(pickingListItems).where(eq(pickingListItems.id, id));
    return result;
  }

  // Returns Management (RF3.3)
  async getReturns(supplierId?: string): Promise<Return[]> {
    // TODO: Implementar quando a tabela returns for adicionada ao schema
    return [];
  }

  async getReturn(id: string): Promise<Return | undefined> {
    // TODO: Implementar quando a tabela returns for adicionada ao schema
    return undefined;
  }

  async createReturn(returnData: InsertReturn): Promise<Return> {
    // TODO: Implementar quando a tabela returns for adicionada ao schema
    throw new Error('Returns table not implemented yet');
  }

  async updateReturn(id: string, returnData: Partial<InsertReturn>): Promise<Return> {
    // TODO: Implementar quando a tabela returns for adicionada ao schema
    throw new Error('Returns table not implemented yet');
  }

  async getReturnItems(returnId: string) {
    // TODO: Implementar quando a tabela returnItems for adicionada ao schema
    return [];
  }

  async createReturnItem(item: any): Promise<any> {
    // TODO: Implementar quando a tabela returnItems for adicionada ao schema
    throw new Error('Return items table not implemented');
  }

  async updateReturnItem(id: string, item: any): Promise<any> {
    // TODO: Implementar quando a tabela returnItems for adicionada ao schema
    throw new Error('Return items table not implemented');
  }

  // Advanced Reports
  async getInventoryTurnoverReport(filters: {
    startDate: Date;
    endDate: Date;
    warehouseId?: string;
    categoryId?: string;
  }) {
    try {
      // Simple inventory turnover query
      const baseQuery = db
        .select({
          productId: products.id,
          productName: products.name,
          sku: products.sku,
          categoryName: categories.name,
          warehouseName: warehouses.name,
          avgStock: sql<number>`COALESCE(AVG(${inventory.quantity}), 0)`,
          totalSold: sql<number>`COALESCE(SUM(CASE WHEN ${stockMovements.type} = 'saída' THEN ${stockMovements.quantity} ELSE 0 END), 0)`,
          turnoverRatio: sql<number>`CASE WHEN AVG(${inventory.quantity}) > 0 THEN COALESCE(SUM(CASE WHEN ${stockMovements.type} = 'saída' THEN ${stockMovements.quantity} ELSE 0 END), 0) / AVG(${inventory.quantity}) ELSE 0 END`
        })
        .from(products)
        .leftJoin(categories, eq(products.categoryId, categories.id))
        .leftJoin(inventory, eq(products.id, inventory.productId))
        .leftJoin(warehouses, eq(inventory.warehouseId, warehouses.id))
        .leftJoin(stockMovements, and(
          eq(stockMovements.productId, products.id),
          sql`${stockMovements.createdAt} >= ${filters.startDate.toISOString()}`,
          sql`${stockMovements.createdAt} <= ${filters.endDate.toISOString()}`
        ))
        .groupBy(products.id, products.name, products.sku, categories.name, warehouses.name);

      // Apply filters
      const conditions = [];
      if (filters.warehouseId) {
        conditions.push(eq(inventory.warehouseId, filters.warehouseId));
      }
      if (filters.categoryId) {
        conditions.push(eq(products.categoryId, filters.categoryId));
      }
      
      const finalQuery = conditions.length > 0 
        ? baseQuery.where(and(...conditions))
        : baseQuery;

      return await finalQuery.orderBy(desc(sql<number>`CASE WHEN AVG(${inventory.quantity}) > 0 THEN COALESCE(SUM(CASE WHEN ${stockMovements.type} = 'saída' THEN ${stockMovements.quantity} ELSE 0 END), 0) / AVG(${inventory.quantity}) ELSE 0 END`));
    } catch (error) {
      console.error('Error generating inventory turnover report:', error);
      return [];
    }
  }

  async getObsoleteInventoryReport(filters: {
    daysWithoutMovement: number;
    warehouseId?: string;
    minValue: number;
  }) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - filters.daysWithoutMovement);

      // Simple obsolete inventory query
      const baseConditions = [
        sql`${inventory.quantity} > 0`,
        sql`${inventory.quantity} * ${products.price} >= ${filters.minValue}`
      ];
      
      if (filters.warehouseId) {
        baseConditions.push(eq(inventory.warehouseId, filters.warehouseId));
      }

      const query = db
        .select({
          productId: products.id,
          productName: products.name,
          sku: products.sku,
          warehouseName: warehouses.name,
          currentStock: inventory.quantity,
          unitPrice: products.price,
          totalValue: sql<number>`${inventory.quantity} * ${products.price}`,
          daysWithoutMovement: sql<number>`30` // Simplified for now
        })
        .from(products)
        .leftJoin(inventory, eq(products.id, inventory.productId))
        .leftJoin(warehouses, eq(inventory.warehouseId, warehouses.id))
        .where(and(...baseConditions));

      return await query.orderBy(sql`totalValue DESC`);
    } catch (error) {
      console.error('Error generating obsolete inventory report:', error);
      return [];
    }
  }

  async getProductPerformanceReport(filters: {
    startDate: Date;
    endDate: Date;
    limit?: number;
  }) {
    try {
      const result = await db
        .select({
          productId: products.id,
          productName: products.name,
          sku: products.sku,
          categoryName: categories.name,
          totalSales: sql<number>`SUM(CASE WHEN ${stockMovements.type} = 'saída' THEN ${stockMovements.quantity} ELSE 0 END)`,
          totalRevenue: sql<number>`SUM(CASE WHEN ${stockMovements.type} = 'saída' THEN ${stockMovements.quantity} * ${products.price} ELSE 0 END)`
        })
        .from(products)
        .leftJoin(categories, eq(products.categoryId, categories.id))
        .leftJoin(stockMovements, and(
          eq(stockMovements.productId, products.id),
          sql`${stockMovements.createdAt} >= ${filters.startDate.toISOString()}`,
          sql`${stockMovements.createdAt} <= ${filters.endDate.toISOString()}`
        ))
        .groupBy(products.id, products.name, products.sku, categories.name, products.price)
        .orderBy(sql`totalRevenue DESC`)
        .limit(filters.limit || 50);

      return result;
    } catch (error) {
      console.error('Error generating product performance report:', error);
      return [];
    }
  }

  async getWarehouseEfficiencyReport(warehouseId?: string) {
    try {
      let query = db
        .select({
          warehouseId: warehouses.id,
          warehouseName: warehouses.name,
          totalProducts: sql<number>`COUNT(DISTINCT ${products.id})`,
          totalStock: sql<number>`SUM(${inventory.quantity})`,
          utilizationRate: sql<number>`0`
        })
        .from(warehouses)
        .leftJoin(inventory, eq(inventory.warehouseId, warehouses.id))
        .leftJoin(products, eq(products.id, inventory.productId))
        .groupBy(warehouses.id, warehouses.name);

      if (warehouseId) {
        const [result] = await query.where(eq(warehouses.id, warehouseId));
        return result;
      }

      return await query;
    } catch (error) {
      console.error('Error generating warehouse efficiency report:', error);
      return warehouseId ? null : [];
    }
  }

  async getStockValuationReport(warehouseId?: string) {
    try {
      const conditions = [sql`${inventory.quantity} > 0`];
      
      if (warehouseId) {
        conditions.push(eq(inventory.warehouseId, warehouseId));
      }

      const query = db
        .select({
          warehouseId: warehouses.id,
          warehouseName: warehouses.name,
          productId: products.id,
          productName: products.name,
          sku: products.sku,
          categoryName: categories.name,
          currentStock: inventory.quantity,
          unitCost: sql<number>`0`,
          unitPrice: products.price,
          totalCostValue: sql<number>`0`,
          totalRetailValue: sql<number>`${inventory.quantity} * ${products.price}`,
          potentialProfit: sql<number>`${inventory.quantity} * ${products.price}`
        })
        .from(inventory)
        .leftJoin(products, eq(inventory.productId, products.id))
        .leftJoin(warehouses, eq(inventory.warehouseId, warehouses.id))
        .leftJoin(categories, eq(products.categoryId, categories.id))
        .where(and(...conditions));

      const results = await query.orderBy(desc(sql<number>`${inventory.quantity} * ${products.price}`));
      
      return {
        items: results,
        summary: {
          totalProducts: results.length,
          totalUnits: results.reduce((sum, item) => sum + (item.currentStock || 0), 0),
          totalCostValue: results.reduce((sum, item) => sum + (item.totalCostValue || 0), 0),
          totalRetailValue: results.reduce((sum, item) => sum + (item.totalRetailValue || 0), 0),
          totalPotentialProfit: results.reduce((sum, item) => sum + (item.potentialProfit || 0), 0)
        }
      };
    } catch (error) {
      console.error('Error generating stock valuation report:', error);
      return { items: [], summary: { totalProducts: 0, totalUnits: 0, totalCostValue: 0, totalRetailValue: 0, totalPotentialProfit: 0 } };
    }
  }

  async getSupplierPerformanceReport(filters: {
    startDate: Date;
    endDate: Date;
    supplierId?: string;
  }) {
    try {
      const baseQuery = db
        .select({
          supplierId: suppliers.id,
          supplierName: suppliers.name,
          totalOrders: sql<number>`COUNT(DISTINCT ${orders.id})`,
          totalAmount: sql<number>`COALESCE(SUM(${orders.totalAmount}), 0)`,
          avgOrderAmount: sql<number>`COALESCE(AVG(${orders.totalAmount}), 0)`,
          completedOrders: sql<number>`COUNT(CASE WHEN ${orders.status} = 'completed' THEN 1 END)`,
          pendingOrders: sql<number>`COUNT(CASE WHEN ${orders.status} = 'pending' THEN 1 END)`,
          deliveryRate: sql<number>`CASE WHEN COUNT(*) > 0 THEN COUNT(CASE WHEN ${orders.status} = 'completed' THEN 1 END) * 100.0 / COUNT(*) ELSE 0 END`,
          productVariety: sql<number>`COUNT(DISTINCT ${products.id})`
        })
        .from(suppliers)
        .leftJoin(orders, and(
          eq(orders.supplierId, suppliers.id),
          sql`${orders.createdAt} >= ${filters.startDate.toISOString()}`,
          sql`${orders.createdAt} <= ${filters.endDate.toISOString()}`
        ))
        .leftJoin(products, eq(products.supplierId, suppliers.id))
        .groupBy(suppliers.id, suppliers.name);

      const query = filters.supplierId 
        ? baseQuery.where(eq(suppliers.id, filters.supplierId))
        : baseQuery;

      return await query.orderBy(desc(sql<number>`COALESCE(SUM(${orders.totalAmount}), 0)`));
    } catch (error) {
      console.error('Error generating supplier performance report:', error);
      return [];
    }
  }

  // ===== FLEET MANAGEMENT IMPLEMENTATIONS =====
  
  // Vehicles
  async getVehicles(): Promise<Array<Vehicle & { driver?: User | null }>> {
    const results = await db
      .select({
        vehicle: vehicles,
        driver: users
      })
      .from(vehicles)
      .leftJoin(users, eq(vehicles.driverId, users.id))
      .orderBy(desc(vehicles.createdAt));
    
    return results.map(result => ({
      ...result.vehicle,
      driver: result.driver
    }));
  }

  async getVehicle(id: string): Promise<Vehicle | undefined> {
    const [vehicle] = await db.select().from(vehicles).where(eq(vehicles.id, id));
    return vehicle || undefined;
  }

  async getVehicleByLicensePlate(licensePlate: string): Promise<Vehicle | undefined> {
    const [vehicle] = await db.select().from(vehicles).where(eq(vehicles.licensePlate, licensePlate));
    return vehicle || undefined;
  }

  async createVehicle(vehicle: InsertVehicle): Promise<Vehicle> {
    await db.insert(vehicles).values(vehicle);
    const insertedVehicle = await db.select().from(vehicles)
      .where(eq(vehicles.licensePlate, vehicle.licensePlate))
      .orderBy(desc(vehicles.createdAt))
      .limit(1);
    return insertedVehicle[0];
  }

  async updateVehicle(id: string, vehicle: Partial<InsertVehicle>): Promise<Vehicle> {
    await db
      .update(vehicles)
      .set({ ...vehicle, updatedAt: sql`now()` })
      .where(eq(vehicles.id, id));
    
    const updatedVehicle = await db.select().from(vehicles).where(eq(vehicles.id, id));
    return updatedVehicle[0];
  }

  async deleteVehicle(id: string): Promise<void> {
    await db.delete(vehicles).where(eq(vehicles.id, id));
  }

  async getVehiclesByStatus(status: string): Promise<Vehicle[]> {
    return await db.select().from(vehicles).where(eq(vehicles.status, status));
  }

  async getAvailableVehicles(): Promise<Vehicle[]> {
    return await db.select().from(vehicles).where(eq(vehicles.status, "ativo"));
  }

  // Vehicle Maintenance
  async getVehicleMaintenance(vehicleId: string): Promise<Array<VehicleMaintenance & { vehicle: Vehicle; performedByUser?: User | null }>> {
    const results = await db
      .select({
        maintenance: vehicleMaintenance,
        vehicle: vehicles,
        performedByUser: users
      })
      .from(vehicleMaintenance)
      .leftJoin(vehicles, eq(vehicleMaintenance.vehicleId, vehicles.id))
      .leftJoin(users, eq(vehicleMaintenance.performedBy, users.id))
      .where(eq(vehicleMaintenance.vehicleId, vehicleId))
      .orderBy(desc(vehicleMaintenance.scheduledDate));
    
    return results.map(result => ({
      ...result.maintenance,
      vehicle: result.vehicle!,
      performedByUser: result.performedByUser
    }));
  }

  async createVehicleMaintenance(maintenance: InsertVehicleMaintenance): Promise<VehicleMaintenance> {
    await db.insert(vehicleMaintenance).values(maintenance);
    const insertedMaintenance = await db.select().from(vehicleMaintenance)
      .where(eq(vehicleMaintenance.vehicleId, maintenance.vehicleId))
      .orderBy(desc(vehicleMaintenance.createdAt))
      .limit(1);
    return insertedMaintenance[0];
  }

  async updateVehicleMaintenance(id: string, maintenance: Partial<InsertVehicleMaintenance>): Promise<VehicleMaintenance> {
    await db
      .update(vehicleMaintenance)
      .set(maintenance)
      .where(eq(vehicleMaintenance.id, id));
    
    const updatedMaintenance = await db.select().from(vehicleMaintenance).where(eq(vehicleMaintenance.id, id));
    return updatedMaintenance[0];
  }

  async getUpcomingMaintenance(): Promise<Array<VehicleMaintenance & { vehicle: Vehicle }>> {
    const today = new Date();
    const in30Days = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
    
    const results = await db
      .select({
        maintenance: vehicleMaintenance,
        vehicle: vehicles
      })
      .from(vehicleMaintenance)
      .innerJoin(vehicles, eq(vehicleMaintenance.vehicleId, vehicles.id))
      .where(
        and(
          sql`${vehicleMaintenance.scheduledDate} <= ${in30Days.toISOString()}`,
          sql`${vehicleMaintenance.scheduledDate} >= ${today.toISOString()}`,
          eq(vehicleMaintenance.status, "agendada")
        )
      );
    
    return results.map(result => ({
      ...result.maintenance,
      vehicle: result.vehicle
    }));
  }

  // GPS Tracking
  async createGpsTracking(tracking: InsertGpsTracking): Promise<GpsTracking> {
    await db.insert(gpsTracking).values(tracking);
    const insertedTracking = await db.select().from(gpsTracking)
      .where(eq(gpsTracking.vehicleId, tracking.vehicleId))
      .orderBy(desc(gpsTracking.timestamp))
      .limit(1);
    
    // Update vehicle's last GPS update
    await db
      .update(vehicles)
      .set({ 
        lastGpsUpdate: sql`now()`,
        isActive: true 
      })
      .where(eq(vehicles.id, tracking.vehicleId));
    
    return insertedTracking[0];
  }

  async getVehicleCurrentLocation(vehicleId: string): Promise<GpsTracking | undefined> {
    const [location] = await db
      .select()
      .from(gpsTracking)
      .where(eq(gpsTracking.vehicleId, vehicleId))
      .orderBy(desc(gpsTracking.timestamp))
      .limit(1);
    return location || undefined;
  }

  async getVehicleGpsHistory(vehicleId: string, hours: number = 24): Promise<GpsTracking[]> {
    const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);
    
    return await db
      .select()
      .from(gpsTracking)
      .where(
        and(
          eq(gpsTracking.vehicleId, vehicleId),
          sql`${gpsTracking.timestamp} >= ${cutoffTime.toISOString()}`
        )
      )
      .orderBy(desc(gpsTracking.timestamp));
  }

  async getAllVehicleLocations(): Promise<Array<GpsTracking & { vehicle: Vehicle }>> {
    const latestLocations = await db
      .select({
        vehicleId: gpsTracking.vehicleId,
        maxTimestamp: sql<string>`max(${gpsTracking.timestamp})`.as('max_timestamp')
      })
      .from(gpsTracking)
      .groupBy(gpsTracking.vehicleId);

    const locations = [];
    for (const latest of latestLocations) {
      const results = await db
        .select({
          tracking: gpsTracking,
          vehicle: vehicles
        })
        .from(gpsTracking)
        .innerJoin(vehicles, eq(gpsTracking.vehicleId, vehicles.id))
        .where(
          and(
            eq(gpsTracking.vehicleId, latest.vehicleId),
            sql`${gpsTracking.timestamp} = ${latest.maxTimestamp}`
          )
        );
      
      if (results[0]) {
        locations.push({
          ...results[0].tracking,
          vehicle: results[0].vehicle
        });
      }
    }
    
    return locations;
  }

  async updateVehicleGpsStatus(vehicleId: string, isActive: boolean): Promise<void> {
    await db
      .update(vehicles)
      .set({ isActive: isActive })
      .where(eq(vehicles.id, vehicleId));
  }

  // Vehicle Assignments
  async getVehicleAssignments(): Promise<Array<VehicleAssignment & { vehicle: Vehicle; driver: User; order?: Order | null; shipment?: Shipment | null }>> {
    const results = await db
      .select({
        assignment: vehicleAssignments,
        vehicle: vehicles,
        driver: users,
        order: orders,
        shipment: shipments
      })
      .from(vehicleAssignments)
      .innerJoin(vehicles, eq(vehicleAssignments.vehicleId, vehicles.id))
      .innerJoin(users, eq(vehicleAssignments.driverId, users.id))
      .leftJoin(orders, eq(vehicleAssignments.orderId, orders.id))
      .leftJoin(shipments, eq(vehicleAssignments.shipmentId, shipments.id))
      .orderBy(desc(vehicleAssignments.createdAt));
    
    return results.map(result => ({
      ...result.assignment,
      vehicle: result.vehicle,
      driver: result.driver,
      order: result.order,
      shipment: result.shipment
    }));
  }

  async getVehicleAssignment(id: string): Promise<VehicleAssignment | undefined> {
    const [assignment] = await db.select().from(vehicleAssignments).where(eq(vehicleAssignments.id, id));
    return assignment || undefined;
  }

  async createVehicleAssignment(assignment: InsertVehicleAssignment): Promise<VehicleAssignment> {
    await db.insert(vehicleAssignments).values(assignment);
    const insertedAssignment = await db.select().from(vehicleAssignments)
      .where(eq(vehicleAssignments.vehicleId, assignment.vehicleId))
      .orderBy(desc(vehicleAssignments.createdAt))
      .limit(1);
    return insertedAssignment[0];
  }

  async updateVehicleAssignment(id: string, assignment: Partial<InsertVehicleAssignment>): Promise<VehicleAssignment> {
    await db
      .update(vehicleAssignments)
      .set({ ...assignment, updatedAt: sql`now()` })
      .where(eq(vehicleAssignments.id, id));
    
    const updatedAssignment = await db.select().from(vehicleAssignments).where(eq(vehicleAssignments.id, id));
    return updatedAssignment[0];
  }

  async getActiveAssignmentsByVehicle(vehicleId: string): Promise<VehicleAssignment[]> {
    return await db
      .select()
      .from(vehicleAssignments)
      .where(
        and(
          eq(vehicleAssignments.vehicleId, vehicleId),
          sql`${vehicleAssignments.status} IN ('atribuido', 'carregando', 'em_transito')`
        )
      );
  }

  async getActiveAssignmentsByDriver(driverId: string): Promise<VehicleAssignment[]> {
    return await db
      .select()
      .from(vehicleAssignments)
      .where(
        and(
          eq(vehicleAssignments.driverId, driverId),
          sql`${vehicleAssignments.status} IN ('atribuido', 'carregando', 'em_transito')`
        )
      );
  }

  // Geofences
  async getGeofences(): Promise<any[]> {
    const results = await db
      .select({
        geofence: geofences,
        warehouse: warehouses,
        createdBy: users
      })
      .from(geofences)
      .leftJoin(warehouses, eq(geofences.warehouseId, warehouses.id))
      .leftJoin(users, eq(geofences.createdBy, users.id))
      .orderBy(desc(geofences.createdAt));
    
    return results.map(result => ({
      ...result.geofence,
      warehouse: result.warehouse,
      createdBy: result.createdBy
    }));
  }

  async getGeofence(id: string): Promise<Geofence | undefined> {
    const [geofence] = await db.select().from(geofences).where(eq(geofences.id, id));
    return geofence || undefined;
  }

  async createGeofence(geofence: InsertGeofence): Promise<Geofence> {
    await db.insert(geofences).values(geofence);
    const insertedGeofence = await db.select().from(geofences)
      .where(eq(geofences.name, geofence.name))
      .orderBy(desc(geofences.createdAt))
      .limit(1);
    return insertedGeofence[0];
  }

  async updateGeofence(id: string, geofence: Partial<InsertGeofence>): Promise<Geofence> {
    await db
      .update(geofences)
      .set(geofence)
      .where(eq(geofences.id, id));
    
    const updatedGeofence = await db.select().from(geofences).where(eq(geofences.id, id));
    return updatedGeofence[0];
  }

  async deleteGeofence(id: string): Promise<void> {
    await db.delete(geofences).where(eq(geofences.id, id));
  }

  async getActiveGeofences(): Promise<Geofence[]> {
    return await db.select().from(geofences).where(eq(geofences.isActive, true));
  }

  // Geofence Alerts
  async getGeofenceAlerts(): Promise<Array<GeofenceAlert & { vehicle: Vehicle; geofence: Geofence; driver?: User | null }>> {
    const results = await db
      .select({
        alert: geofenceAlerts,
        vehicle: vehicles,
        geofence: geofences,
        driver: users
      })
      .from(geofenceAlerts)
      .innerJoin(vehicles, eq(geofenceAlerts.vehicleId, vehicles.id))
      .innerJoin(geofences, eq(geofenceAlerts.geofenceId, geofences.id))
      .leftJoin(users, eq(geofenceAlerts.driverId, users.id))
      .orderBy(desc(geofenceAlerts.createdAt));
    
    return results.map(result => ({
      ...result.alert,
      vehicle: result.vehicle,
      geofence: result.geofence,
      driver: result.driver
    }));
  }

  async createGeofenceAlert(alert: InsertGeofenceAlert): Promise<GeofenceAlert> {
    await db.insert(geofenceAlerts).values(alert);
    const insertedAlert = await db.select().from(geofenceAlerts)
      .where(eq(geofenceAlerts.vehicleId, alert.vehicleId))
      .orderBy(desc(geofenceAlerts.createdAt))
      .limit(1);
    return insertedAlert[0];
  }

  async acknowledgeGeofenceAlert(id: string, acknowledgedBy: string): Promise<GeofenceAlert> {
    await db
      .update(geofenceAlerts)
      .set({ 
        acknowledgedBy: acknowledgedBy,
        acknowledgedAt: sql`now()`
      })
      .where(eq(geofenceAlerts.id, id));
    
    const updatedAlert = await db.select().from(geofenceAlerts).where(eq(geofenceAlerts.id, id));
    return updatedAlert[0];
  }

  async getActiveGeofenceAlerts(): Promise<GeofenceAlert[]> {
    return await db.select().from(geofenceAlerts).where(eq(geofenceAlerts.alertType, "entry"));
  }

  // GPS Sessions
  async createGpsSession(session: InsertGpsSession): Promise<GpsSession> {
    await db.insert(gpsSessions).values(session);
    const insertedSession = await db.select().from(gpsSessions)
      .where(session.vehicleId ? eq(gpsSessions.vehicleId, session.vehicleId) : sql`1=1`)
      .orderBy(desc(gpsSessions.startedAt))
      .limit(1);
    return insertedSession[0];
  }

  async updateGpsSession(id: string, session: Partial<InsertGpsSession>): Promise<GpsSession> {
    await db
      .update(gpsSessions)
      .set(session)
      .where(eq(gpsSessions.id, id));
    
    const updatedSession = await db.select().from(gpsSessions).where(eq(gpsSessions.id, id));
    return updatedSession[0];
  }

  async getActiveGpsSessions(): Promise<Array<GpsSession & { user: User; vehicle?: Vehicle | null }>> {
    const results = await db
      .select({
        session: gpsSessions,
        user: users,
        vehicle: vehicles
      })
      .from(gpsSessions)
      .innerJoin(users, eq(gpsSessions.userId, users.id))
      .leftJoin(vehicles, eq(gpsSessions.vehicleId, vehicles.id))
      .where(eq(gpsSessions.status, "ativo"));
    
    return results.map(result => ({
      ...result.session,
      user: result.user,
      vehicle: result.vehicle
    }));
  }

  async endGpsSession(sessionId: string): Promise<GpsSession> {
    await db
      .update(gpsSessions)
      .set({ 
        status: "finalizado",
        endedAt: sql`now()`
      })
      .where(eq(gpsSessions.id, sessionId));
    
    const endedSession = await db.select().from(gpsSessions).where(eq(gpsSessions.id, sessionId));
    return endedSession[0];
  }

  // RBAC - Roles Implementation
  async getRoles(): Promise<Array<Role & { _count?: { permissions: number; users: number } }>> {
    return await db.select().from(roles).orderBy(desc(roles.createdAt));
  }

  async getRole(id: string): Promise<Role | undefined> {
    const [role] = await db.select().from(roles).where(eq(roles.id, id));
    return role || undefined;
  }

  async createRole(role: InsertRole): Promise<Role> {
    await db.insert(roles).values(role);
    const insertedRole = await db.select().from(roles)
      .where(eq(roles.name, role.name))
      .orderBy(desc(roles.createdAt))
      .limit(1);
    return insertedRole[0];
  }

  async updateRole(id: string, role: Partial<InsertRole>): Promise<Role> {
    await db
      .update(roles)
      .set({ ...role, updatedAt: sql`now()` })
      .where(eq(roles.id, id));
    
    const updatedRole = await db.select().from(roles).where(eq(roles.id, id));
    return updatedRole[0];
  }

  async deleteRole(id: string): Promise<void> {
    await db.delete(roles).where(eq(roles.id, id));
  }

  // RBAC - Permissions Implementation
  async getPermissions(): Promise<Permission[]> {
    return await db.select().from(permissions).orderBy(permissions.module, permissions.action);
  }

  async getPermission(id: string): Promise<Permission | undefined> {
    const [permission] = await db.select().from(permissions).where(eq(permissions.id, id));
    return permission || undefined;
  }

  async createPermission(permission: InsertPermission): Promise<Permission> {
    await db.insert(permissions).values(permission);
    const insertedPermission = await db.select().from(permissions)
      .where(eq(permissions.name, permission.name))
      .orderBy(desc(permissions.createdAt))
      .limit(1);
    return insertedPermission[0];
  }

  async updatePermission(id: string, permission: Partial<InsertPermission>): Promise<Permission> {
    await db
      .update(permissions)
      .set(permission)
      .where(eq(permissions.id, id));
    
    const updatedPermission = await db.select().from(permissions).where(eq(permissions.id, id));
    return updatedPermission[0];
  }

  async deletePermission(id: string): Promise<void> {
    await db.delete(permissions).where(eq(permissions.id, id));
  }

  async getPermissionsByModule(module: string): Promise<Permission[]> {
    return await db.select().from(permissions).where(eq(permissions.module, module));
  }

  // RBAC - Role Permissions Implementation
  async getRolePermissions(roleId: string): Promise<Permission[]> {
    const results = await db
      .select({ permission: permissions })
      .from(rolePermissions)
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(eq(rolePermissions.roleId, roleId));
    
    return results.map(result => result.permission);
  }

  async addPermissionToRole(data: InsertRolePermission): Promise<RolePermission> {
    await db.insert(rolePermissions).values(data);
    const insertedRolePermission = await db.select().from(rolePermissions)
      .where(and(eq(rolePermissions.roleId, data.roleId), eq(rolePermissions.permissionId, data.permissionId)))
      .orderBy(desc(rolePermissions.createdAt))
      .limit(1);
    return insertedRolePermission[0];
  }

  async removePermissionFromRole(roleId: string, permissionId: string): Promise<void> {
    await db.delete(rolePermissions)
      .where(
        and(
          eq(rolePermissions.roleId, roleId),
          eq(rolePermissions.permissionId, permissionId)
        )
      );
  }

  async setRolePermissions(roleId: string, permissionIds: string[]): Promise<void> {
    // Remove todas as permissões existentes do role
    await db.delete(rolePermissions).where(eq(rolePermissions.roleId, roleId));
    
    // Adiciona as novas permissões
    if (permissionIds.length > 0) {
      const rolePermissionsData = permissionIds.map(permissionId => ({
        roleId,
        permissionId
      }));
      await db.insert(rolePermissions).values(rolePermissionsData);
    }
  }

  // RBAC - User Roles Implementation
  async getUserRoles(userId: string): Promise<Role[]> {
    const results = await db
      .select({ role: roles })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));
    
    return results.map(result => result.role);
  }

  async getUsersWithRole(roleId: string): Promise<User[]> {
    const results = await db
      .select({ user: users })
      .from(userRoles)
      .innerJoin(users, eq(userRoles.userId, users.id))
      .where(eq(userRoles.roleId, roleId));
    
    return results.map(result => result.user);
  }

  async addRoleToUser(data: InsertUserRole): Promise<UserRole> {
    await db.insert(userRoles).values(data);
    const insertedUserRole = await db.select().from(userRoles)
      .where(and(eq(userRoles.userId, data.userId), eq(userRoles.roleId, data.roleId)))
      .orderBy(desc(userRoles.createdAt))
      .limit(1);
    return insertedUserRole[0];
  }

  async removeRoleFromUser(userId: string, roleId: string): Promise<void> {
    await db.delete(userRoles)
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(userRoles.roleId, roleId)
        )
      );
  }

  async setUserRoles(userId: string, roleIds: string[]): Promise<void> {
    // Remove todos os roles existentes do usuário
    await db.delete(userRoles).where(eq(userRoles.userId, userId));
    
    // Adiciona os novos roles
    if (roleIds.length > 0) {
      const userRolesData = roleIds.map(roleId => ({
        userId,
        roleId
      }));
      await db.insert(userRoles).values(userRolesData);
    }
  }

  async getUserPermissions(userId: string): Promise<Permission[]> {
    const results = await db
      .select({ permission: permissions })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .innerJoin(rolePermissions, eq(roles.id, rolePermissions.roleId))
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(eq(userRoles.userId, userId));
    
    // Remove duplicatas
    const uniquePermissions = Array.from(
      new Map(results.map(result => [result.permission.id, result.permission])).values()
    );
    
    return uniquePermissions;
  }

  async hasPermission(userId: string, permissionName: string): Promise<boolean> {
    const result = await db
      .select({ count: sql<number>`count(*)` })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .innerJoin(rolePermissions, eq(roles.id, rolePermissions.roleId))
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(permissions.name, permissionName),
          eq(roles.isActive, true)
        )
      );
    
    return result[0]?.count > 0;
  }
}

export const storage = new DatabaseStorage();
